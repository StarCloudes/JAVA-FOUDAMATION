# 线程池知识

## 1.创建线程池----Executors

Eexecutor作为灵活且强大的异步执行框架，其支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程和执行过程解耦开发，基于生产者-消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者，并用Runnable来表示任务，Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。

Java通过Executors提供四种线程池，分别为：

 newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 

newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

newWorkStealingPool jdk8增加了newWorkStealingPool(int parall)，增加并行处理任务的线程池，不能保证处理的顺序。

注意：1.线程池只是为了控制应用中处理某项业务中防止高并发问题带来的线程不安全的发生的概率。我们可以通过线程池指定处理这项业务最大的同步线程数，比如：Executors.newFixedThreadPool(3);在线程池中保持三个线程可以同时执行，当某个线程执行结束后，会有新的线程进来。newFixedThreadPool.execute(new ThreadForpools());这句话的含义是添加新的处理业务请求进来。线程复用的意思是：通过控制可以在规定的时间内当线程现有的任务完成了，可以继续完成新的任务。

2. 线程组和线程池的区别

线程组是为了方便线程的管理 线程池是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。

## 2.线程池原理

提交一个任务到线程池中，线程池的处理流程如下：

1、判断**线程池里的核心线程**是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。

2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。

3、判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

![](http://www.uml.org.cn/j2ee/images/2012121931.jpg)



​    刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。

　　当然，为了达到我需要的效果，上述线程处理的任务都是利用休眠导致线程没有释放！！！

### RejectedExecutionHandler：饱和策略

当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是AbortPolicy，表示无法处理新的任务而抛出异常。JAVA提供了4中策略：

1、AbortPolicy：直接抛出异常

2、CallerRunsPolicy：只用调用所在的线程运行任务

3、DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。

4、DiscardPolicy：不处理，丢弃掉。



## 3.线程池优化-----https://www.cnblogs.com/10158wsj/p/8338367.html       

多线程的使用方法:

   ### 第一种：单线程

   　　这种方式非常简单，但是程序在处理的过程中非常的耗时，使用的时间会很长，因为每个线程都在等待当前线程执行完才会执行，和多线程没有多少关系，所以效率非常低。

   ### 第二种：ThreadPool（线程池）+CountDownLatch（程序计数器）

   CountDownLatch为线程计数器，他的执行过程如下：首先，在主线程中调用await()方法，主线程阻塞，然后，将程序计数器作为参数传递给线程对象，最后，每个线程执行完任务后，调用countDown()方法表示完成任务。countDown()被执行多次后，主线程的await()会失效

   ### 第三种：Fork/Join框架

   Fork/Join框架执行思想：首先，分割任务，使用fork类将大任务分割为若干子任务，这个分割过程需要按照实际情况来定，直到分割出的任务足够小。然后，join类执行任务，分割的子任务在不同的队列里，几个线程分别从队列里获取任务并执行，执行完的结果放到一个单独的队列里，最后，启动线程，队列里拿取结果并合并结果。

   ### 第四种JDK8并行流

​       并行流是jdk8的新特性之一，思想就是将一个顺序执行的流变为一个并发的流，通过调用parallel()方法来实现。并行  流将一个流分成多个数据块，用不同的线程来处理不同的数据块的流，最后合并每个块数据流的处理结果，类似于Fork/Join框架。

并行流默认使用的是公共线程池ForkJoinPool，他的线程数是使用的默认值，根据机器的核数，我们可以适当调整线程数的大小。线程数的调整通过以下方式来实现。

System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "100");

总结：综上几种情况来看，以单线程作为参考，耗时最长的还是原生的Fork/Join框架，这里边尽管配置了线程池的数量，但效果较精确配置了线程池数量的JDK8并行流较差。并行流实现代码简单易懂，不需要我们写多余的for循环，一个parallelStream方法全部搞定，代码量大大的减少了，其实，并行流的底层还是使用的Fork/Join框架，这就要求我们在开发的过程中灵活使用各种技术，分清各种技术的优缺点，从而能够更好的为我们服务。

总之:使用JDK8并行流最好



## 4.线程池的优点

- ####  线程池的重用

 线程的创建和销毁的开销是巨大的，而通过线程池的重用大大减少了这些不必要的开销，当然既然少了这么多消费内存的开销，其线程执行速度也是突飞猛进的提升。

- #### 控制线程池的并发数

回到线程池，控制线程池的并发数可以有效的避免大量的线程池争夺CPU资源而造成堵塞。

- #### 线程池可以对线程进行管理

 线程池可以提供定时、定期、单线程、并发数控制等功能。比如通过ScheduledThreadPool线程池来执行S秒后，每隔N秒执行一次的任务