 第一天
1.把jdk等工具给学生，并安装
2.配置环境
3.进行简单的helloworld程序的讲解--java,javac的
4.简单语法的讲解
  关键字，标识符，变量，常量   数据类型
进制转换   ：介绍二进制   八进制   十进制  十六进制   
             介绍原理
             介绍进制转换   负数的二进制表示      字节的范围

5变量的具体讲解
例子：计算两个数的和  变量：存储程序中用到的数据，一个变量只能存储一个数据，这个数据是可变的
讲解数据类型
byte
short
int
float
double
char     编码：将字符转化成一个具体的数的过程叫编码，这个数在计算机内部存储的是二进制码
java默认使用的编码是unicode     a-97    A-65    0-48
常见的编码格式 美国标准：  ASCII     国标码：gbk  gb2312    欧洲编码：ISO8859-1    通用性编码：utf-8

float f = 4.5  一个小数默认被看成double类型    所以要写成 f = 4.5f  
int a = 4 一个整数默认被看成int类型

java中设置精度方法：通过BigDecimal类或者Stringformat：方法

数据类型决定了变量占据多大的内存，同时决定了变量存储什么类型的数

6.数据类型转换   
数据类型级别的高低：byte,short,char-int-long-float-double
自动类型转换

强制类型转换

7.转义字符 

第二天
1.算数运算符   + - * / %（取模） ++ --
2.赋值运算符 =  +=  -=  /=  %= *=
3.关系运算符   >  >=  <  <=  ==   !=
4.逻辑运算符  ！ && ||  
5.位运算符 & | ^  ~  
//位运算符，是对二进制数进行操作
		/*
		|:按位或，两个数同一二进制位，有一个为1，结果就是1
                &（按位与），两个数同一二进制位，都为1，结果才是1，否则为0
		^（按位异或）：两个数同一二进制位，相异时，结果为1，相同时，为0
		 ~（非）：按位取反

		 ①用按位与运算将特定位清0或保留特定位；
		 ②用按位或运算将特定的位置设置为1；
		 ③用按位异或运算将某个变量的特定位翻转或交换两个变量的值。

移位运算符 >>带符号右移位  <<带符号左移位  >>>无符号右移位

//移位运算符  >> 向右移位，相当于除法（移一位相当于除以2）  <<相当于乘法  >>>相当于无符号移位
		//注意：浮点型的数据不能用移位运算
  负数的无符号右移位，高位补零  ，有符号右移位，高位补一
		*/
6.if  else 
7.if   else if   else
////需求2：根据用户指定月份，打印该月份所属的季节。
        //3,4,5 春季 6,7,8 夏季  9,10,11 秋季 12, 1, 2 冬季
8.switch(表达式)
{ case 取值1：  break；
  case 取值2：  break；
  。。。。。。
  default：
        执行语句；
         break；
}
9.循环  while    do  while 
10.for（int i = 0;i<3;i++）
11.for循环的各种形式  


有时间介绍   三目运算符 ?:   


第三天
1.嵌套循环
打印矩形星星
/*

*
**
***
****
*****


1
12
123
1234
12345



九九乘法表
1*1=1
1*2=2 2*2=4
1*3=3 2*3=6 3*3=9


*/

/*
打印一个实心菱形图案
   *
  ***
 *****
*******
 *****
  ***
   *

*/

/*3.打印一个空心菱形图案
  问题：用*号打印一个如下的空心菱形图案 ：

                   *
                  * *
                 *   *
                *     *
                 *   *
                  * *
                   *

*/

//编写一个程序，最多接收10个数，求这些数的和，
        //用户可以通过输入999终止程序，并显示输入数的和


2.函数
/*
返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数2，……)
	{
			执行语句;
			return 返回值;
	}
*/





第四天
1.剩余函数
1.确定一个函数必须通过参数，返回值，函数名三项，完全一样
/*
函数的重载：在同一个class 中，出现了函数名称相同但参数不同的现象

重载的函数参数不同：
参数的个数不同
参数的类型不同
个数和类型都不同

注意:重载和返回值无关
*/
2.有返回值，所有位置都要有return
3.函数的内存表达
/*
		java在运行程序的时候，JVM将内存分成五部分：栈区，堆区，方法区，本地方法区，寄存器。

		栈区：存储数据时先进后出，存储的变量是局部变量，使用完立即回收（释放）内存

		堆区：存储的都是实体（对象，数组），可以存储多个数据
		特点：1.在堆区中，变量如果没有赋值，系统会默认为0
		
		2.当引用被赋值成null时，数组会通过垃圾回收机制进行回收，控制垃圾回收机制的是一个线程，线程的级别较低，所以不会马上回收。
		
		*/
4.自定义函数
函数命名规则  驼峰原则
5.闰年  ，400的整数倍或者4的整数倍同时不是100的整数倍



/*
public static void show(int a,double d,boolean b)

a:public static int show(int a,double d,boolean b)

b:public static int show(int c,double e,boolean m)

c:public static void show(int a,double d)

d:public static void show(int a,boolean n,double d)

e:public static void show(int a)




*/
2.数组
作用：存储多个数据
特点：存储多个数据，是一种数据类型，属于引用数据类型

定义数组

//定义一个存储5个数的数组
int[] arr = new int[5]； 在内存中开辟了可以存储5个整数的空间

JVM讲内存分成五块：栈区，堆区，方法区，本地方法区，寄存器  

栈：存储的是局部变量（函数或语句中定义的变量），先进后出
     局部变量特点：作用域一结束，变量马上被释放

堆：存储的都是实体（数组，对象），实体都是可以存储多个数据
 特点：1.变量会赋默认值  0
2.当引用被赋值成null时，对象会通过垃圾回收机制进行回收，控制垃圾回收机制的是一个线程，线程的级别较低，所以不会马上回收。

数组超出范围  报错  抛出异常 ArrayIndexOutOfBoundsException   NullPointerException
数组的初始化

通过数组交换两个数的值，写成函数

求最大值  写成函数



第五天
选择排序  写成函数 selectedSort(int[] arr,int i,int j)
冒泡排序           bubbleSort（int[] arr,int i,int j）

//查找:一个数在数组中第一次出现的位置（下标），不存在返回-1

二分查找   //二分法查找：前提条件：数组必须是从小到大排好序的
Arrays

二维数组的介绍  new  int[3][4]         new  int[3][]        {{3,4},{5,6,7}}

面向对象   大象    举例
对象与类的关系
用车举例创建类，并创建对象
画图，从内存的角度说明问题

/*
局部变量和成员变量的对比：
1:
局部变量没有默认值
成员变量有默认值
2：
局部变量是当其所在的函数被调用时在栈中开辟内存
成员变量是当对象创建时在堆中开辟内存
3：
局部变量是当其作用域结束了就释放在栈中的内存
成员变量是当其所属的对象被垃圾回收时才释放内存
4：
局部变量的作用域是从其定义的位置开始，到其所在的大括号结束
成员变量的作用域是整个类
*/


第六天
面向对象的三大特性：继承，封装，多态

封装：将实现的细节封装在一个独立的空间内，外部要想操作他，只能通过对应的函数访问。


构造函数：创建对象的，同时给属性赋值
          默认有一个构造方法，
          如果自定义后，程序就不会再创建默认的构造方法
构造方法特点：1.函数名与类名同名
             2.没有返回值
             3.不能单独被调用

匿名对象



第七天

this  //this:是一个引用，总是指向当前正被使用的对象
             1.区分成员变量和局部变量
             2.代表当前的对象
             3.在构造方法中调用其他的同名称不同参数的狗造方法，这样可以：代码的复用，
            注意：1.自己调用自己，死锁   2.要写在第一行

get，set方法
 
//1，将给定数组进行反转。{32,65,12,89,41} {41,89,12,65,32}
//2，将给定的数组变成字符串，[元素1,元素2...]
			//{34,12,65} --> "[34,12,65]"

//static:可以修饰成员变量，成员函数
/*
被static修饰的成员变量的特点：

1：static修饰的成员变量是其所属类的所有对象共享
2：static修饰的成员变量是随着类的加载就在方法区的静态区开辟内存了，所以优先于非静态存在
3：static修饰的成员变量既可以通过对象来访问也可以通过类名直接访问

静态成员变量占据内存时间长

静态成员变量和非静态成员变量的对比:
1:存储的数据
  非静态成员变量存储的是其所属类的每个对象特有属性的数据
  静态成员变量存储的是其所属类的所有对象共享属性的数据
2：存储的位置
  非静态成员变量是随着对象的创建在堆中开辟内存
  静态成员变量是随着类的加载在方法区中的静态区开辟内存
3: 生命周期
  非静态成员变量是当其所属的对象被创建时才开辟内存，当其所属的对象被垃圾回收时就释放内存
  静态成员变量随着类的加载在方法区中的静态区开辟内存，程序退出时才释放内存
4：访问方式
  非静态成员变量只能通过对象来访问
  静态成员变量既可以通过对象来访问也可以通过类名直接访问


静态只能用静态，非静态既可以用静态也可以用非静态
*/ 

/*
什么情况下使用static?

什么情况下把成员变量修饰为static的？
     当希望该成员变量的值被所属类的所有对象共享时
   

什么情况下把成员函数修饰为static的？
     当该函数没有直接用到所属类的任何非静态成员时
*/

/*
public static void main(String[] args) 

public:说明访问权限是最大的
static:说明该函数随着类的加载就加载的方法区的静态区了
void:说明无返回值
main:函数名，被JVM锁识别，是程序运行的入口

String[] args:参数是一个字符串类型的数组
*/

第八天

/*
静态代码块:随着类的加载就执行，只执行一次，优先于main 函数的执行
可以实现类的初始化
*/

/**
这是一个定义了数组常用功能的工具类，比如求最值，排序，查找等
*/
求最值
public static int getMax(int[] arr)
	{
		int max = arr[0];
		for(int i=1;i<arr.length;i++)
		{
			if(arr[i]>max)
				max = arr[i];
		}
		return max;
	}
}

排序
public static void selectSort(int[] arr)
	{
		for(int i=0;i<arr.length-1;i++)
		{
			for(int j=i+1;j<arr.length;j++)
			{
				if(arr[j]<arr[i])
				{
					huan(arr,j,i);
				}
			}
		}
	}

	private  static void huan(int[] arr,int i,int j)
	{
		int t;
		t = arr[i];
		arr[i] = arr[j];
		arr[j] = t;
	}
查找
public static int halfSearch(int[] arr,int key)
	{
		int min = 0,max = arr.length-1,mid;
		while(min<=max)
		{
			mid = (min+max)>>1;
			if(key>arr[mid])
				min = mid+1;
			else if(key<arr[mid])
				max = mid-1;
			else
				return mid;
		}
		return -1;
	}

/*
构造代码块：对象一创建就执行，且优先于构造函数的执行
构造代码块可以对所有对象进行初始化
构造函数只能针对特定的对象进行初始化
*/

/*
对象的初始化过程：
1：因为创建对象需要字节码文件，所以先加载字节码文件到方法区
2: 如果有静态代码块执行静态代码块
3：在堆中开辟内存
4: 给成员变量赋默认值
5: 给成员变量赋初始值
6：执行构造代码块
7：执行构造函数
8: 把对象在堆中的内存地址赋给栈中的引用变量
*/

/*
设计模式：解决某一类问题最有效的方式
单例设计模式：解决的是一个类只有一个对象的问题

1:构造函数私有化
2:在类中创建自身类型的对象
3:把对象提供出去，通过定义一个public的静态函数返回该对象
*/


//工厂加工零件儿   解释单例设计模式的作用

//通过例子将狗造方法，static，this进行复习

//求两点之间的距离（x1,y1,z1）到 (x2,y2,z2)
//设计类   Point类

//题  学生学习英语，数学，语文
要求：有属性 年龄，姓名，英语，数学，语文，总成绩，平均分
//设计类： 学生类    

//题：求圆的面积和周长

//设计类：点 ，圆（Circle）

//继承：1.作用：实现了代码的复用，优化了代码，修改更加便利，代码更加安全，增加了代码的健壮性 ，使类与类之间产生了关系，被继承的是父类，继承的是子类

java中的继承是单继承  ，直接的父类只有一个，可以有多个间接的父类

//继承中 this与super的使用   this是一个引用，代表当前的对象    super：不是引用，只有当父类与子类出现同名的情况才使用

//继承中成员变量的特点:
//this是一个应用，指向当前对象，super不是引用，当子父类中出现同名现象时，使用super来区分

//继承中成员函数的特点:
/*
重写（覆盖）:子类中出现了和父类中一样的函数，当创建子类对象并调用一样的函数时，执行的是子类的

注意：1：父类中的私有方法不能被重写
      2：子类在重写父类中的方法时，子类中的方法的权限要大于等于父类中方法的权限
	  3: 静态只能覆盖静态
*/

/*继承中构造函数的特点:在创建子类对象时，总是先执行父类的构造方法，再执行子类的构造方法
                       原因是系统自动在子类的构造方法的第一行加入了一条语句 super()
					   super()默认是调用父类中无参的构造函数

为什么要先调用父类的构造方法?子类继承父类，必然会把父类中的属性继承过来，
                             可以利用父类的构造方法对继承过来的属性进行初始化

注意:如果父类中没有空参的构造方法，那么子类必须手动加入 super语句
*/



第九天
值传递与地址传递的区别

说明通过super可以调用父类的构造方法

实现两个类通信方式：三种
继承  谁是谁      组合：谁属于谁    传参：

//final:修饰 类，方法，成员变量，局部变量

/*
一个类被修饰为final的，那么这个类不能有子类
一个方法被修饰为final的，那么这个方法不能被重写
一个成员变量或者局部变量被修饰成final的，那么这个变量的值不能被修改，作为参数的形式参数也一样

总之：被final修饰的就会变成最终的。

//举例  面积    单例
*/

/*
//抽象类：在提取父类的时候，某个方法每个子类都有自己的实现方式，父类不能决定如何实现，
//那就不决定了，我们在父类中只写方法的声明，不写实现，我们成这样的方法是抽象方法，有抽象方法的类是抽象类

/*特点：1.抽象类不能创建对象
* 2.继承了抽象类的类，如果没有实现抽象类的方法，那这个子类也是抽象类
*/

/*抽象类：
 * 1.抽象类是父类吗？
 * 是
 * 2.抽象类与普通类区别：
 * 不同点：
 * a：抽象类不能创建对象，普通类可以
 * b：抽象类可以含有抽象方法，普通类不可以
 * 相同点：
 * 都是类，都是在描述事物
 * 
 * 3.abstract不可以跟那些关键字并用
 * final：使用final修饰的方法不能被重写，abstract必须可以重写
 * static：可以通过类名调用，abstract不能被调用
 * private：使用private修饰的方法不能被重写，abstract必须可以重写
 * 
 * 4.一定有抽象方法吗？
 * 不一定，只要是不想让当前类创建对象
 * 
 * 抽象类也是类，用来描述事物，只是包含有一些没有实现的方法

//举例： 计算圆和矩形的面积
 * */

/*
需求：公司中程序员有姓名，工号，薪水，工作内容。
项目经理除了有姓名，工号，薪水，还有奖金，工作内容。
对给出需求进行数据建模。


 * interface 接口名
 * {
 * 		public static final 成员变量  ////接口是抽象的，不能创建对象（实例化），
	                        //不要在里面放入非静态的成员变量
	                        //，static是静态的，可以通过接口名称调用，
	                         //final：因为这里要得到一个不能改变的存储空间
 * 		public abstract 成员方法
 * }
 * 
 * 接口解决了java的单继承的问题
 * 因为接口中的方法都是抽象的，一个类在实现接口时，重写了接口中的抽象方法
 * 当创建子类对象并调用该方法时，很明确是在调用重写之后的方法，所以不会出现调用的不确定性
 * 
 * */

//1.在jdk1.8的接口中可以写方法的实现,方法必须是default或static的
//2.接口还是不能直接创建对象,要通过子类
/*
 * 接口的子类重写方法注意事项
 * 如果一个类实现两个接口，这两个接口同时有相同的抽象方法，在类中只需要重写一次这个方法。 
如果接口中有default修饰的方法不需要重写。 
如果两个接口里的方法名相同都是default方法，里面的方法体不同，在类中需要重写该方法。 
如果两个接口中方法名，参数都相同的方法，一个接口是抽象方法，另一个是default修饰有方法体。这是该类也必须重写该方法。
 */

/*
一个类在继承的同时还可以实现接口

类和类之间是继承关系
类和接口之间是实现关系

通过继承可以得到继承体系的基本功能
通过实现可以得到继承体系之外的功能

接口和接口之间是继承关系，可以多继承

*/

/*
1：接口是一些规则
2：可以提高程序的扩展性
3：降低类之间的耦合关系


//举例：说明抽象类 犬科动物--- 警犬，导盲犬，搜爆犬    接口  扩充功能  

多态：
通常的定义：事物的多种形态
多态：父类的引用指向子类的对象就是多态
前提：有继承
缺点：只能访问父类中定义的功能
好处：可以提高程序的扩展性，前期定义好的功能后期可以使用

举例：猫  动物（可以写抽象类）

/*
进一步说明：定义一个方法实现多个子类的功能
举例：猪，狗，马   动物  
*/    


第十天

/*
在多态中访问子类中特有的功能
向上转型
向下转型    使用  （ 对象引用  instanceof  对应的类 ） //instanceof是一个运算符，是用来在运行时指出对象是否是一个特定类或者他的子类的实例
*/

/*
多态中成员的特点:
成员变量：编译时期能访问哪些成员变量看父类,运行时看子类有没有与父类同名的，有看子类，没有看父类
非静态成员函数：编译时期能访问哪些成员函数看父类，执行结果看子类（当子类重写了父类的方法时，没有重写看父类）
静态函数：编译执行都看父类

写一个程序说明Fu，Zi

/*
/接口和多态--实现了接口的类可以看成接口的子类
写一个程序说明：inter，Test1,Test2
*/
/*
根据以下这段话的描述，用面向对象的思想实现

狗生活在陆地上（是一种陆生动物），既是哺乳(mamma)类的也是肉食(carnivorous)性的。
狗通常的时候和人打招呼会通过“摇摇尾巴”，在被抚摸情绪很好的时候，
会“旺旺叫”，而在受到惊吓情绪(mood)烦躁时，会发出“呜呜”声；

猫也生活在陆地上（是一种陆生动物），既是哺乳类的也是肉食性的。
猫通常的时候和人打招呼会发出“喵～”的声音，在被抚摸情绪很好时，
会发出“咕噜咕噜”声，而在受到惊吓情绪烦躁时，会发出“嘶嘶”声；

青蛙是一种两栖动物（既是水生动物也是陆生动物），既不是哺乳类的也不是肉食性的，
属于卵生。青蛙通常的时候和人打招呼会通过"呱呱叫"，当青蛙情绪好的时候，
会在岸边“呱呱呱”的唱歌，而在受到惊吓情绪烦躁时，会"扑通一声跳入水中"
*/

/*
讲解Object类的基本方法使用
*/

/*
内部类
//内部类：在一个类内部定义的类,内部类属于外部类的成员，所以和外部类中的其他成员是平级的，所以可以相互使用
//内部类可以直接使用外部类中的成员
*/

//静态成员内部类:如果内部类中含有静态成员，那么内部类必须是静态的

//内部类中获取外部类对象：外部类名.this

//局部内部类：只能在它所在的函数使用,局部内部类使用了其所在函数的局部变量时，该局部变量必须是final 的


第十一天
//匿名内部类：前提条件：存在父类或父接口
//匿名内部类:处于类的内部,并且是匿名的,叫匿名内部类.相当于Test的一个子类对象,匿名内部内是局部内部类的一种
		//匿名内部类不能使public,static,protected,private
匿名内部类作用:1.只用到一个实例,定义好马上使用,命名并不会更好,可以方便的定义运行时回调
内部类作用:1.内部类对象可以访问创建他的对象的实现,包括私有数据
2.内部类不为同一包的其他类所见,具有很好的封装性
3.可以方便定义


/*异常：程序在运行时出现的不正常情况
 * 异常的由来：程序在运行时出现的不正常情况被看成了对象，提取属性和行为进行描述
 * （比如异常信息，异常名称，异常发生的位置），从而形成了各种异常类
 * 
 * Throwable
 * ---Error ：运行时出现的严重问题，不用写相关的代码处理
 * ---Exception:不严重的问题，通常需要进行处理
 * 
 * */

 /*分析：当发生下标越界时，因为这种下标越界异常java内部已经定义好了，所以系统会自动创建该异常类对象，
          * 因为main函数处理不了这种异常抛给了JVM，JVM默认的处理方式就是调用该异常类对象的printStackTrace()方法，
          * 打印出异常信息，异常名称，异常位置，然后程序终端
          * */

//发生异常时：会先在MyMath类的方法处出现异常，不能处理，抛出异常，抛给main函数，main函数不能处理异常，抛给JVM

/*
 * try{//可以检测异常
 * 	   可能出现异常的代码
 * }
 * catch(Exception e){//接收try检测出的异常
 * 	  对代码进行处理
 * }
 * 
 * 继续执行
 */

/*使用throws声明可能发生的异常，那么调用者必须处理
 *处理方式有两种
1：使用try{}catch(异常类 e){}处理
2：继续使用throws声明可能发生异常 //只是针对main函数中的对异常的处理
 * 
 */

//多重异常
//可以同时抛出多个异常，父类的异常要放在所有子类异常的最下面

//自定义异常
//除数为负数是异常




第十二天
/*运行时异常
 * 使用throw手动抛出异常，不用处理，编译通过
 * 使用throws手动声明异常，不用处理，编译通过
 * 
 * 异常分类：
 * 一种是编译时检测的异常，必须处理，不处理不通过
 * 一种是编译时不检测的异常，可通过
 * 
 * java认为发生运行时异常，程序应该中断，不应该处理
 * 因为运行时异常都是由于数据错误造成的
 * */

//数组中指定下标  ArrayIndexOutOfBoundsException   NullPointerException

/*
 * try{
 *    出现异常的代码
 * }
 * catch(Exceptin e){
 *     处理方式
 * }
 * finally{
 * 	      必须执行的代码   可以用来在执行多线程，数据库是的内存释放问题   
 * catch中出现return 照样会执行  出现exct()不会，此时程序退出
 * }
 */

	/*//与异常无关
		 * try{
		 * 获取资源
		 * }
		 * finally{
		 * 释放资源
		 * }
		 */

举例：//老师用电脑上课
//老师上课时异常
//上课时电脑的异常：蓝屏，冒烟


模板设计模式:在实现一个功能时，功能的一部分是确定的，另一部分是不确定的，
确定的部分还会用到不确定的部分，那么就把不确定的部分暴露出去，让子类去完成

/*

计算一个程序的运行时间：
获取程序运行的开始和结束时间是确定的，然后两个时间相减
被计算运行时间的程序是不确定的
*/

//字符串  定义
字符串的存储
new String()是一个新字符串

重写equals

/*
一些常用的方法
//验证用户名和密码是否正确
throw new NullPointerException();
//验证邮箱是否合法
throw new NullPointerException();

*/

/*
   判断：
        判断是否包含一个字符串
		  boolean contains(CharSequence s) 
        判断两个字符串的内容是否相同
		  boolean equals(Object anObject) 
        忽略大小写判断两个字符串的内容是否相同
		  boolean equalsIgnoreCase(String anotherString) 
         判断是否以某字符串开头
		   boolean startsWith(String prefix)
		 判断是否以某字符串结尾
		   boolean endsWith(String suffix) 
    转换：将字符数组转换成字符串
			  1:使用构造方法
				 String(char[] value) 
				 String(char[] value, int offset, int count) 
			  2:使用静态方法
				 static String copyValueOf(char[] data) 
				 static String copyValueOf(char[] data, int offset, int count) 
		  将字符串转成字符数组
              char[] toCharArray() 
 
		  将字节数组转成字符串
		      String(byte[] bytes) 
              String(byte[] bytes, int offset, int length)
			  String(byte[] bytes, String charsetName)//使用指定的编码将字节数组转换成字符成
		  将字符串转成字节数组
		      byte[] getBytes() 
 

		  将基本数据类型转换成字符串
		      String.valueOf()
    替换：
	     String replace(char oldChar, char newChar) 
 
	子串:
	     String substring(int beginIndex)  
		 String substring(int beginIndex, int endIndex) //包含起始位置，不包含结束位置，到结束位置的前一位
 
	转换，去除空格，比较:
	     大小写转换
		     String toLowerCase() 
             String toUpperCase()
		 将字符串两端的空格去掉
		     String trim() 
		 按字典顺序比较两个字符串
             int compareTo(String anotherString)
	切割: String[] split(String)

*/

/*
存储：
    StringBuffer append(boolean b) 
    StringBuffer insert(int offset, boolean b)
删除：
     StringBuffer delete(int start, int end) 
     StringBuffer deleteCharAt(int index)
修改：
     StringBuffer replace(int start, int end, String str) 
     void setCharAt(int index, char ch)

获取：
     char charAt(int index) 
	 int indexOf(String str)
	 int indexOf(String str, int fromIndex)
	 int lastIndexOf(String str) 
          返回指定子字符串在此字符串中的索引从右到左查。 
     int lastIndexOf(String str, int fromIndex) 
          返回指定子字符串在此字符串中的索引,从右到左查,范围:0-当前指定的位置。 
     int length() 
          返回长度（字符数）。 

反转：
     StringBuffer reverse() 

从jdk1.5出现了StringBuilder,它是线程不安全的
在不需要多线程安全的前提下建议使用StringBuilder,执行的效率高

jdk升级的原因：
1：提高效率
2: 提高安全性
3: 简化书写


举例：打印一个矩形


*/

第十三天
/*
包装类 ：
byte    Byte
short   Short
int     Integer
long    Long
char    Character
boolean Boolean
float   Float
double  Double

可以实现基本数据类和字符串类型之间的转换

基本类型转成字符串类型
    static String Integer.toString(int i)
    static String Double.toString(double d)
字符串类型转基本类型
    int     Integer.parseInt("23")
	double  Double.parseDouble("3.45")

把十进制转成其它进制
   Integer.toHexString()
   Integer.toOctalString()
   Integer.toBinaryString()

把其它进制转十进制
  Integer.parseInt(数据,进制)
*/

装箱
拆箱

问题:在jdk1.8下出现不能装箱,拆箱?
jre(核心类库),没有更新版本,版本停留在1.4

查看编译器(complier)的方法
window->属性->java->compiler

 //一个数在一个字节允许的范围之内，如果之间已经定义过，那么再定义时使用已有的
*/

/*                          private            默认(default,frendly)   protected            public

同一个类中                    可以             可以                   可以                 可以

同一个包中                    不               可以                   可以                 可以

不同的包中有继承关系          不               不                     可以                 可以

不同的包没继承关系            不               不                     不                   可以

四种访问权限： 
1.public：只能修饰类、方法（含构造方法）、成员变量。其修饰的部分所有人都能访问；

2.默认修饰符（friendly）：只能修饰类、方法（含构造方法）、成员变量。其修饰的部分只有同一包内的类能访问，对于这个包之外的所有类，这个成员是private的；

3.private：只能修饰方法（含构造方法）、成员变量。其修饰的部分只能在自身类中访问。例如将某类的构造方法设置为private，那么在其它类中就不能调用“new”来创建该类的实例，通常在该类中会对外提供一种方法，该方法能返回该类的实例；再例如我们经常将成员变量设置为private的，对外提供set/get方法对其进行访问，在set/get方法中可做一些比如权限检测等操作，而不是将域直接暴露给所有用户；

4.protected：只能修饰方法（含构造方法）、成员变量。

在同一包中具有包访问权限，相当于默认访问权限；
在不同包内：访问权限赋予派生类（继承树的第一个子类―C导出类） 
1.在子类中，可继承不同包内父类的protected方法和属性，也只能在该子类中访问（除非重写方法或属性）


//Date类
输出时间
long转Date
Date转long

//DateFormat  ---日期的格式化
DateFormat 创建系统的类
SimpleDateFormat  创建自定义的类

//Calendar  

//Maths
//最小值  最大值    平方   开方   随机数  随机类


/*
存储多个不同类型的对象:
Object[]  arr = new Object[10];
数组的缺陷是：一旦数组存满了，就不能再继续存了

集合：可以存储不同类型的对象，而且随着存储的对象的增加容量自动扩大
画图  Collection    List     ArrayList   Vector     LindedList
                    set      HashSet     TreeSet   

/*
Collection中定义是整个集合体系最共性的方法:
添加：
   boolean add(Object o) 
   boolean addAll(Collection<? extends E> c)  
删除:
   boolean remove(Object o)  
   boolean removeAll(Collection<?> c)
   void clear()
判断:
   boolean contains(Object o) 
   boolean containsAll(Collection<?> c)
   boolean isEmpty() //判断集合是否为空
   boolean equals(Object o) 
获取：
   Iterator<E> iterator() //获取集合中的对象
   int size() //获取集合中对象的个数
集合变数组：
   Object[] toArray()
*/

//迭代器的使用

第十四天
//继续集合  Collection:
List:存储的对象是有序的（集合中对象的顺序和添加对象的顺序是一致的），可以重复的
      ArrayList：底层使用的数据结构是数组，线程不安全的，查抄速度快，增删速度慢
      LinkedList：底层使用的数据结构是链表，线程不安全的，查找速度慢，增删速度快
      Vector：底层使用的数据结构是数组，线程安全的，查找速度快，增删速度慢，被ArrayList替换
Set：存储的对象是无序的，不可以重复的。

List：特有方法，可以操作下标
增：
    void add(int index, E element) 
    boolean addAll(int index, Collection<? extends E> c) 

删
   E remove(int index) 

改
   E set(int index, E element)

查
     ListIterator<E> listIterator() 
     返回此列表元素的列表迭代器（按适当顺序）。 
     ListIterator<E> listIterator(int index) 
     List<E> subList(int fromIndex, int toIndex) 
     E get(int index) 
     
     删除全部对象
*/

/*
Iterator 的remove方法介绍
ListItrerator 的remove，add，set等方法的介绍
//注意：set方法不可以与add和remove同时使用
*/

/*
Vector的创建
使用枚举打印
*/

/*
LindedList
特有的方法：

addFirst()//始终在首位添加
addLast()//始终在末尾添加

getFirst()//获取的对象不存在会发生异常
getLast()

removeFirst()//删除的对象不存在会发生异常
removeLast()

从jdk1.6开始出现以下方法
offerFirst()
offerLast()

peekFirst()//获取的对象不存在会返回null
peekLast()

pollFirst()//删除的对象不存在会返回null
pollLast()
*/

/*
使用LinkedList实现队列

*/

/*
去重
contains 依据的是equals（Object o）方法 
*/

/*
给自定义的类去重，理解去重
*/

/*HashSet*/
/*Set:存储的对象是无序的，不可以重复的
HashSet：底层使用的数据结果是哈希表，线程不安全的
         
		   保证对象唯一的方式: int hashCode()   boolean equals(Object obj)
            在添加对象时先用对象的哈希值和集合中对象的哈希值分别进行比较，如果和
		   集合中所有对象的哈希值都不相同，那么直接把对象加入集合，如果出现哈希值相同的
		   那么再调用 equals方法对象哈希值相同的两个对象进行比较，如果equals方法返回true
		   则认为是同一对象，不把该对象加入集合，否则认为是不同的对象，加入集合

/*详细介绍*/

/*TreeSet*/
//在使用add方法添加对象时会对对象自动进行排序
//内部实现了接口Comparable 中的int comparaTo（）方法
/*详细介绍*/
  TreeSet: 底层使用的数据结构是二叉树, 线程不安全的
		          可以对存入集合的对象进行排序

				  排序方式一:集合中对象所属的类 实现了Comparable接口中的int compareTo()方法
				             TreeSet依据该方法进行排序

							 保证对象唯一的方式： compareTo()方法的返回值是0


第十五天

//自定义一种排序方式：按照字符串的长短比较大小
//在使用add方法添加对象时就已经比较大小了，所以必须在使用 add方法之前就确定比较方式

//使用在自定义的对象上
举例：学生

//举例：
//将字符串转存到TreeSet集合，并排序
//"23 45 12 6 78"

/*
泛型：通过<数据类型>接收一种引用数据类型，在编译程序时会使用该类型检查集合中存储的对象是否是该
      类型的，如果不是，编译不通过，从而把运行时期的问题转移到编译时期，提高了程序的安全性

使用泛型不需要强制类型转换了

泛型擦除：泛型是用在编译时期的，编译完之后的class文件中是不存在泛型的
*/
举例：工人，学生，工具类

//定义泛型类----在类上定义泛型
//使用泛型前

//在方法上面定义泛型       //方法的泛型与类的一致，类的确定了，方法的就确定了 //希望方法参数是任意类型时，自己使用泛型

                            ////静态进内存的时候没有对象，所以只能自己使用泛型

//在接口上面定义泛型        //如果子类没有遵守接口的泛型，方法的泛型与接口的保持一致    //类上的泛型确定了，接口上的才能确定

//通配符 ？的使用

//泛型限定： ? extends E :可以接收E类型或E类型的子类类型，确定了上限           
//           ? super E：可以接收E类型或 E类型的父类类型，确定了下限

举例：人，学生，工人

泛型上限的使用  TreeSet<E> 
                TreeSet<? extends E> c

举例   父类

//// TreeSet<E> TreeSet(Comparator<? super E> comparator)   Student Person

//// TreeSet<E> TreeSet(Comparator<? super E> comparator)   Worker Person


第十六天
/*
Map:是一个单独的接口，不属于Collection,属于集合，一对一对的存，称为键值对

    HashMap:底层使用的数据结构是哈希表，线程不安全的
	TreeMap:底层使用的数据结构是二叉树，线程不安全的

添加:
 V put(K key, V value) 
 void putAll(Map<? extends K,? extends V> m)
 
删除:
 V remove(Object key) 
 void clear() 
         
获取：
  V get(Object key) 

  Set<K> keySet() 
  Set<Map.Entry<K,V>> entrySet() 
  int size() 
  Collection<V> values() 
判断:
   boolean isEmpty() 
   boolean containsKey(Object key) 
   boolean containsValue(Object value) 

*/

/*
遍历Map集合的方式:
 Set<K> keySet(): 得到所有键的集合存储到一个Set中，并返回该Set集合，因为Set有迭代器
                  所以使用迭代器迭代，每次迭代出一个键，再根据键获取值

 Set<Map.Entry<K,V>> entrySet(): 得到每个键值对对应的映射关系类型的值，存到Set集合中，并
                    返回该集合，因为Set有迭代器，每次迭代出来的是一个映射关系类型的值，从这个
					映射关系类型的值中既可以得到键，也可以得到值
					Entry是定义在Map中的一个静态接口，
					有了集合，有了集合中的键值对，才会存在映射关系，所以映射关系是对集合内部
					事物的描述，所以定义在Map内部

*/

举例：每个学生对应一个地址
//HashMap：去重
//TreeMap：两种排序

HashMap: 保证键不能重复的原理和HashSet是一样的

TreeMap:根据键来排序，排序的原理和TreeSet是一样的

//练习:字符串"oeiproitwoeuraecdefgabcdefg"
//希望打印结果:a(2)b(1)c(2)

//有两个班级，每个班级有多个学生，遍历所有班级并显示每个班所有学员

Arrays:
//把数组中的数据转成字符串
//数组转集合 

//数组转成的集合不能进行添加和删除
		//因为数组的长度是固定的

//为什么要数组转集合？集合的方法多

//集合存储的是引用类型的对象，因为数组是引用类型的，所以把整个数组作为
		                                 //一个对象存在集合中
第十七天
Collections：操作集合的工具类
//需要存储多个对象，要求对象可以重复并且要排序  可以重复只能是List，要进行排序--自己指定排序方法
//static <T extends Comparable<? super T>>  sort(List<T> list)
//会按照int compareTo()方法或者 int compare方法，排序，因为是String所以内部默认使用int compareTo()自动进行了排序
//通过自定义的比较类排序

//介绍三个sort方法

reverseOrder
//实现对自定义的排序方法的倒序
//实现对默认的排序方法的倒序

//反转指定列表中元素的顺序
//reverse方法

//求最大值  max
//写求最大值的方法，讲解原理
//<T extends Object & Comparable<? super T>>限定方法中的T是继承自Objet类并且实现了Comparable接口
public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> col)

/*
 * Collection接口中的toArray方法
 * <T> T[] toArray(T[])  将集合转化成数组
 */

/*
		 * 首先会创建一个新的数组
		 * 当将集合转化成数组时，如果指定的数组的大小比集合的大，转化完的数组长度以指定数组为准
		 * 当将                               ，如果指定的数组的大小比集合的小，转化完的数组长度以集合为准
		 * 综上最好指定与集合相等的长度
		 */

/*
 * 增强for循环
 * 格式  
 * for(数据类型 变量:要遍历的数组或集合)  此处的集合不包括Map
 * {
 * }
 * 
 * 单独遍历Map
 */

/*
 * 可变参数：简化书写

//内部原理：也是将接受到的数据存入到一个数组里面
//注意：1.格式  数据类型后面加三个点，只能是三个点 2.如果方法有多个参数，必须将可变参数放在所有参数的最后面
 */


第十八天
//当方法名同名时，必须使用类名来区分方法
//当类名重名时，包名不能省 

/*
 * 多线程：
 * 程序：可以运行的一个文件
 * 进程：正在进行中的一个程序，也就是在内存中开辟的一块儿内存空间
 * 
 * 线程：负责程序执行的一条执行路径（代码片段），也可以成为一个执行单元
 *     进程的执行实际上是线程在执行
 *     一个进程至少有一个线程在工作
 *     如果一个进程中有多个线程在工作，我们成之为多线程
 *     
 * 多线程的优点：可以实现不同功能的同时执行
 * 功能：防止界面假死，实现异步功能（实现数据的下载）
 * 
 * 多线程一定好吗？不一定
 * 缺点：不一定能提高效率，可以合理的使用cpu资源
 * 
 * JVM是多线程吗？是
 * 
 * 举例：垃圾回收机制
   
   main是主线程，自己重写finalize方法回收垃圾，调用System.gc触发垃圾回收机制

 * 至少有一个负责程序正常执行的线程，也就是执行main函数中的代码-主线程
 * 还要有一个负责垃圾回收的线程，也就是finalize函数中的代码-垃圾回收线程
 * 
 * 任务：每个线程需要执行的代码
 *     任务代码都有其存储位置
 *     
 *     主线程的任务代码在main函数中
 *     垃圾回收线程的任务代码在finalize函数中
 *     
 *线程是随着任务的存在而存在，任务的结束而消失
 */
比较sleep()与yield()
1.sleep()
使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据。
2.yield()
该方法与sleep()类似，只是不能由用户指定暂停多长时间，并且yield（）方法只能让同优先级的线程有执行的机会。

/*
 * 创建线程
 * 同时执行show方法
 * 
 * 需要使用多线程
 * 创建线程的第一种方法：
 * 1.创建一个类继承Thread
 * 2.重写Thread类的run方法
 * 		创建线程是为了执行任务
 *      任务代码必须有存储位置，run方法就是线程的存储位置
 * 3.创建子类对象，其实就是创建线程
 * 4.启动线程
 * 		主线程的任务代码在main中
 * 		子线程的任务代码在run方法中 
 * 
为什么用start不用run？
注意:run方法必须是public 的
 * run方法只是简单的方法调用，不具备启动线程的功能
 * start方法会启动线程并执行run方法

  Thread.currentThread().getName()  获取当前线程的名字

  //这样直接用Thread创建线程，也启动了线程，但是没有执行任务代码的地方，因为Thread类中的run方法没有实现任何功能
  Thread th1 = new Thread();

 * 
   画多线程的内存图

 * 每个线程在栈中都有一块儿内存，之间是独立的
当线程执行完代码后，线程就会从栈中消失
当所有线程执行完后，进程结束

通过异常理解线程之间独立
 */

//画线程状态图

/*
创建第二种线程
/*
 * 四个窗口同时买票
 * 因为同时买票，所有使用多线程，创建4个线程
 * 4个任务是一样的，只需定义一个子类继承自Thread类
 * 
 * 解决4个人共享票的问题，另一种创建线程的方法
 * 1.创建Runnable接口的子类
 * 2.重写Runnable接口的run方法
 * 3.创建子类的对象
 * 4.创建线程类的对象，即创建线程
 * 5.将创建的子类对象作为参数，赋给4中创建线程的构造方法
 * 
 * //这里相当于将线程和任务都面向对象了
 * 实现了线程任务与线程对象的分离，线程执行什么任务不再是唯一的，
 * 只要是实现了Runnable子类的对象都可以作为任务，作为参数传递给线程对象的构造方法即可
 * 
 * 第二种在实现接口的同时还可以继承父类，所以不应想子类的正常工作，而第一种直接将子类与线程进行了绑定，运行起来不方便
 * 
 */
*/


//由于Thread本身也实现了Runnable接口，所以下面这样写也可以，只是不推荐
/*
 * 总结一下：为什么创建第二种线程可以解决4个人同时买票问题？
 * 第一种创建线程的方式：线程任务与线程对象时绑定在一起的，创建4个线程就创建了4分资源
 * 第二种创建线程的方式：线程任务与线程对象是分离的，只需创建 一个任务，让四个线程取执行
 */
第十九天
/*

  画图说明安全问题

 * 程序出现了安全问题： 会出现0，-1，-2，-3的情况
 * 
 * 出现问题的原因：
 * 1.多个线程操作了相同的数据
 * 2.共享数据的语句有多条，一个线程得到cpu，执行了多条语句的一部分时，还没有全部执行完，
 * 就被抢走了cpu，当线程再次得到cup时，直接执行后面的语句导致问题的出现
 *
 *解决办法：一个线程得到cup，执行了多条语句的一部分时，其他线程不能抢走cpu，只有当该线程把
 *所有共享数据的语句全部执行完后，其他的线程才能抢走cpu
 *
 *java提供的方法：同步代码块（同步锁)
 *    synchronized(对象){注意：这里锁必须是对象
 *    	共享数据的语句
 *    }
 *    
 * 同步代码块的缺点：线程每次都要判断锁，降低了程序的性能
 * 
 * 使用同步的条件：
 * 1.至少有两个线程
 * 2.多个线程使用同一把锁
 */

/**
一个银行可以存钱
两个储户同时向一个账户存钱，每人存3次，每次存100

分析：同时存钱，所以使用多线程
两个储户，所以是两个线程

创建的类：银行类      任务类
 */

/*
 * 注意：当在一个类中同时存在多个synchronized修饰的代码块儿或函数时，要想安全，就必须让他们后面的对象一致。因为只有同一把锁才能安全。
 * 同步函数的锁：this
 * 静态同步函数在进内存的时候不会创建对象，但是存在其所属类的字节码文件对象，属于class类型的对象，所以
 * 静态同步函数的锁是其所属类的字节码文件对象
 * 
 * 
 * * 理解synchronized关键字
 * 1、synchronized关键字的作用域有二种： 
1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象
的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的
一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。
这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时
访问相同类的另一个对象实例中的synchronized方法； 
2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问
这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。
2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，
表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象；

3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 
在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定
它的某个方法为synchronized方法；
*/

//死锁：同时存在多个锁，并且相互嵌套调用，这是，有可能发生，同时互相占用，无法工作的情况。

//线程锁在单例中的应用
//用懒汉式创建单例容易发生并发访问的安全问题

//所以：建议大家在创建单例时尽量使用饿汉式

//线程间的通信：两个线程，执行不同的任务，操作相同 的数据


第二十天

画图讲解  wait，notify等的使用

//线程间的通信：两个线程，执行不同的任务，操作相同 的数据
//为什么wait（），notify（），notifyAll（）在Object类里面？
 * 因为这些命令必须要在线程进行同步的前提下才能使用，并且要使用锁调用，而所有的锁都是Object（对象）。
 * 
 * wait（） 将线程放到线程池
 * notify（） 唤醒持有当前锁的某一个线程
 * notifyAll（）唤醒所有线程
 */

//简化代码：使程序更加面向对象
//存储数据，输出数据本来就应该由数据类来完成

/*
 * 生产者消费者问题----类似于输入输出数据问题
 * 这里描述的单生产者单消费者--没有安全问题
 * 
 * 生产者有生产任务
 * 消费者有消费任务
 * 
 * 生产和消费可以同时进行
 * 使用多线程
 * 
 * 需要描述生产任务
 * 需要描述消费任务
 * 
 * 生产的是产品
 * 消费的也是产品
 * 
 * 需要描述产品
 * 
 */

/*
 * 描述两个生产者两个消费者
 * 
 * 两个生产线程，两个消费线程，出现了生产三次，消费一次，生产一次，消费三次的问题
 * 原因：线程被唤醒之后没有回去判断标记，直接执行后面的代码
 * 解决：将if改为while
 * 
 * 修改完后，线程出现了死锁
 * 原因：唤醒的是本方的线程，导致所有线程全部等待   notify唤醒的是任意一个线程，不能保证唤醒对方的线程
 * 解决：使用notifyAll（），将线程全部唤醒，保证对方程序被唤醒
 */

/*jdk 1.5之前使用的是
 * synchronized(对象){//获取锁
 * 		//同步代码
 * }//释放锁
 * 这是一种隐式方法
 * 
 * jdk1.5开始使用显示的方法  直接将锁面向对象了
 * 1.创建锁对象
 * 2.调用锁对象的lock（）方法获取锁

 * 3.调用锁对象的unlock（）方法释放锁
 * 
 * wait，notify等方法在1.5之前是直接与对象（锁）绑定在一起，1.5之后，将他们也面向对象了，被放在了Condition接口中，
 * 但是还是要与锁进行绑定，所以可以进行等待等操作的Condition接口对象是通过调用锁对象的 newCondition()方法得到的
 * 
 * 
 */

/*//使用jdk1.5 多线程的实现方式 解决一次唤醒所有线程性能低的问题
* 采取方法提高效率：signalAll()还是会唤醒所有的线程  ，浪费资源，这里只需要唤醒对方的线程，
* 所以我们采用给线程指定Condition对象的方式实现

 //得到和锁绑定的Condition对象，控制生产线程的唤醒和等待
 //得到和锁绑定的Condition对象，控制消费线程的唤醒和等待
*/

//使用jdk1.5的多线程实现方式实现可以同时多生产多消费的功能


第二十一天
//多线程的其他知识点   
/*
线程的停止：stop方法已经过时，只能是当线程的任务代码执行完线程自然结束
办法：任务代码都有循环，所以只要让循环停下来线程就能停下来    通过设立状态值flag，改变flag的值，实现
2.实现wait方法的时候，线程会进入等待状态，通过执行interrupt方法中断等待状态，触发InterruptedException异常,这时可以让flag = false，执行一次循环结束
 */

//守护线程：可以看成后台线程，依赖于前台线程，当前台线程全部结束时，即使后台线程的任务代码没有执行完成，也会立刻结束

//join方法：加入运行
//让t1线程加入运行,这时只有主线程和t1线程，所以主线程会等待t1线程全部执行完再执行

//匿名内部类创建实现线程

/*
IO流：处理设备之间的数据传输
Input   Output

按照方向分:输入流，输出流

按照操作的数据分:字节流，字符流

字节流：可以操作任何类型的数据实现输入和输出
        文本，音频，视频，图片

字符流：只能针对文本实现输入和输出
        在字节流的基础上融入了编码，方便文本的输入和输出

字节流：两个父类

字节输入流的父类: InputStream
字节输出流的父类：OutputStream

字符流：两个父类

字符输入流的父类：Reader
字符输出流的父类：Writer

设备：键盘，控制台，内存，硬盘，网络

以硬盘为例学习输入和输出
*/

//向文本文件中写入数据
//分析：是文本文件，所以使用字符流，是写入 所以使用字符输出流Writer，又因为是文件，
//所以使用可以向文件中写入数据的字符输出流FileWriter
//1.创建文件输出流对象并与被写入数据的文件相关联，注意：这时如果在这里已经存在一个名为temp.txt的文件，会被覆盖，不存在会自动创建
//2.使用输出流对象向文件中写入数据
//数据写入到输出流对象的内部数组中了，这是一个字节数组，因为要查编码表，把编码的结果写入文件

//写文件时出现异常，进行抛出处理
//注意：如果路径是不存在的，会创建文件失败，同时输出流对象创建失败
//因为输出流对象创建失败，所以这里f = null，所以出现异常 NullPointerException


//文件的续写  调用  FileWriter(String fileName, boolean append) 方法

画图分析

//将数据从文本文件中读出
/* 分析：操作的是文本文件，所以使用字符流   ，进行的是读出，所以使用输入字符流  Reader， 操作的是文件使用 FileReader
//1.创建输文件入字符流对象和被读取的文件关联

//注意：文件必须是存在的

*/2. 读取数据  先使用  int read()方法  读取单个字符，返回的是字符编码

//int read(char[]  cbuf) 将字符读入数组    参数：是要存读出的数据   返回值：是这次读出的字符的个数

//复制一个java文件
//使用字符读取流读取被复制的文件，每次读出来的数据写入到新的文件

//使用读取单个字符的方法

//使用读取字符数组的方法

第二十二天
/*
 * 字符流的缓冲区：缓冲区是为了提高效率，只具备提高效率的功能，不具备读或写的功能，所以使用缓冲流必须结合着输入流或者输出流
 * 我们可以把它看做一个高速的小车
 * 
 * 与字符流一样缓冲流被面向对象了，分成两种类型的流
 * BufferedReader:只具备提高读效率的功能，本身不能读
 * BufferedWriter:只具备提高些效率的功能，本身不能写   newLine方法
 * 
 */

//使用缓冲写入流实现文件的写入
//1.因为BufferedWriter不具备写的功能，所以需要先创建字符写入流对象和文件相关联
//2.为了提高效率，使用缓冲写入流
//把需要提高效率的字符输入流对象作为参数传递给BufferedWriter的构造方法

/*
 * BufferedReader:只具备提高效率的功能，不具备读的功能
 * 提供了readLine方法，更加方便的进行数据的读取
 */
//读取一行文本,单本身不具有换行的能力，当文件读完时，返回null

//进行文件的复制   使用缓存流，并进行异常处理


//LineNumberReader    获取行号，设置行号

/*
 * 装饰设计模式：基于已经存在的功能，提供增强的功能

画图理解
 * 
 * 装饰设计模式的由来：
 * 
 * Reader
 *   子类：TextReader
 *       MediaReader
 *       
 * 为了提高子类的读的效率
 * Reader
 *     TextReader
 *        BufferedTextReader
 *      MediaReader
 *        BufferedMediaReader
 *     OtherReader
 *     	  BufferedMediaReader
 * 既然都是提高读的效率，那就把这个功能提取出来，封装到一个类中，谁需要提高效率就把谁作为参数传递给该类的狗造访啊
 * 
 * 使用张氏设计模式后的体系
 * Reader
 *     TextReader
 *        
 *      MediaReader
 *        
 *     OtherReader
 *     BufferedReader
 *     
 * 总结作用：1.是原来的继承体系变简单了
 * 2.因为实在原有功能的基础上提供增强工功能，所以这个类还属于原的体系
 */

//模拟BufferedReader，自定义一个类MyBufferedReader   直接给  
原来的有问题:重写的myRead()方法,无法读出最后的一行数据,当只有一行时,什么都得不到  ????????


/*
 * 字节流：
 * OutputStream
 * InputStream
 * 
 */
//一种写       
   三种读    读一个字节     读多个字节      读全部字节

//复制图片    只能使用字节流
//读一个字节
//读多个字节
//读全部字节  异常处理+字节缓冲流的使用



第二十三天
//标准输入流    in    画图理解
 //标准的输入流，系统将这个流与键盘进行了绑定，可以直接从键盘接收数据，注意：这是个字节流
//int num = in.read();//读入一个字节    光标会停在这里，等待你输入，因为这是一个阻塞式方法。从键盘读数据

//例子：循环读取键盘输入的数据，够一行了打印大写形式，不够一行时存储 

/*
 * 刚才的功能（循环读取键盘里面的数据），与BufferedReader方法的readLine很相似
 * 
 * 那如果可以使用readLine方法实现刚才的功能就会非常简单
 * 
 * 分析
 * System.in  是字节流
 * BufferedReader 字符流
 * 
 * 要讲字节流转成字符流。。。。。。通过转换流InputStreamReader  
把字节输入流转成字符输入流的类:  InputStreamReader
把字节输出流转成字符输出流的类 ：OutputStreamWriter

//定义标准的字节输出流
//把字节输出流转成字符输出流
// 为了提高效率，使用BufferedWriter
 */

/*
 * 输入:键盘
 * 目的:控制台
 * 
 * 输入:键盘
 * 目的:文件
 * 
 * 输入:文件
 * 目的:控制台
 */

//改变标准的输入
//改变标准的输出

/*
 * File文件类:用于操作与文件相关的操作
 * 生成文件类对象
 * 创建文件
 * 创建路径
 * 创建多层路径
 * 
 * 判断是否是文件
 * 判断是否是路径
 * 判断是否隐藏
 * 输出最后修改文件的时间
new SimpleDateFormat("yyyy-MM-dd E HH:mm:ss").format(new Date(file.lastModified()))
 */

/*
 * 查找方法
 * //列出所有的系统根
 *  //列出指定目录下的所有的文件和文件夹，以字符串形式返回
 *  //列出指定目录下的所有的文件和文件夹，以File形式返回
 */

/*
 * 递归:函数自己调用自己
 * 
 * //注意： 1：内存溢出 2：要有结束调用的条件
 */

/*
   递归的应用:
 * 列出指定目录下面的所有内容及子目录中的内容
 */

第二十四天
/Properties
//Properties:是一个Map集合,存储的是属性,属性是以键值对的方式存在,且键值都必须是字符串类型的,所以他没有使用泛型
		           //因为他可以跟流结合使用,所以在讲流的同时将他
//1.先介绍基本使用
//可以通过重置的方式,重新赋值.因为这是Map的特点,当前的会覆盖上一次的值
//2.介绍系统的属性
//3.介绍工作的原理   先创建文件,将属性保存进去,   读取文件内容,进行修改    3.重新写回文件

//打印流 PrintStream
/*
 * 打印流  PrintStream  具备了字节输出流的基本功能,增加了打印功能
 * 可以输出的设备:1.File类型的文件
 * 	2.字符串类型的文件
 * 	3.字节输出流

//因为默认是字节流,所以只能读取一个字节  其他的砍掉
//内部默认调用了string.valueof().getBytes方法
 */
//打印流 PrintWriter
/*
 * 打印流  PrintWriter  具备了字节输出流的基本功能,增加了打印功能
 * 		可以输出的设备:1.File类型的文件
 * 		2.字符串类型的文件
 *		3.字节输出流
 * 		4.字符输出流
 */

//序列流  SequenceInputStream
/*
 * 序列流SequenceInputStream:可以连续打印多个流
 * 通过Vector的枚举   或者集合的枚举Enumeration

FileInputStream   FileOutputStream
 */

//对象的序列化
/*
 * 对象的序列化
 * 对象的序列化依赖的是一个UID编码,如果没有自己指定,在序列化时,会自动指定一个,但是当改变类是,这个UID会发生变化,读取失败.可以自己指定UID??
 //所有序列化的对象都要实现Serializable接口,虽然这个接口没有方法,但是这里相当于一个规则
 //给类指定的serialVersionUID
	static final long serialVersionUID = 42L;

//对象的反序列化,读取对象使依赖的是其字节码文件Person.class
transient:作用是限制成员变量不可反序列化

序列化
反序列化
 */
//随机访问
/*
 * 随机访问
 * RandomAccessFile:不属于IO体系,只能访问文件,内部既有字节输出流,又有字节输入流,通过制定读写的方式区分读写
 * 					内部有一个字节数组,可以通过指针设置,所以可以随机访问
 

随机写入
//模式为"rw",那么当文件不存在时会自动创建
//获取指针指向的当前位置
//指针指向哪里,数据从哪里开始写
随机读出
*/

第二十五天
/*
 * 数据流  DataInputStream    DataOutputStream
//注意:读出的顺序和存入的顺序要保持一致
 * 
 * //注意:读出的顺序和存入的顺序要保持一致
 */

/*
 * 内存流      ByteArrayOutputStream     写入内存,在内部有 一个内部的数组,数据被放在里面
 * 	       ByteArrayInputstream     从内存中读出,即从字节数组中读出
 */

/*
 * 转换流的编码问题
 * 编码:将字符串等转化成byte序列的过程
 * 编码错误的原因:在读入,与写出的过程中使用的编码格式不同,造成编码错误

//转换流的编码问题
//默认编码:gbk  一个汉字2个字节    utf-8编码  一个汉字 3个字节
		//使用utf-8写   用gbk读    乱码:浣濂
		//使用gbk读,utf-8写  乱码:??
 */

/*
 * 
 * 编码:发电报   "你好,请给bigData班每人发10000元"  ----编码 ------     字节序列
 * 
byte[] getBytes() 
使用平台的默认字符集将此 String 编码为 byte 序列，
并将结果存储到一个新的 byte 数组中。 

byte[] getBytes(Charset charset) 
使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 

String(byte[] bytes) 
通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。

String(byte[] bytes, Charset charset) 
通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。
*/

//这里使用gbk编码,使用ISO8859-1解码,编码解码不统一,出错
		//编码错了,解码也会错
		//编码正确,解码不对,可以先利用解码时的编码格式进行再编码,然后使用原来编码时的编码格式再解码
		//作用:后面使用tomcat服务器时,使用的欧洲编码.经常要再编码再解码

ISO8859-1 欧洲编码

/*
 * 
 * 网络知识:网络通信三要素:
 * 1网络协议:http,https,UDP,TCP等
 *   UDP:面向无连接的,不安全,速度快,发送的是数据包
 *   TCP:面向连接的,安全,速度要慢,发送的是流
 * 2.IP地址 :127.0.0.1本地保留地址(访问自己的电脑)     对应的类:InetAddress
 * 3.端口号:0-65535(只能是这个范围)
 * 
 * 使用Socket(套接字)完成通信(干活)
 * 
 * 七层协议:了解
 应用层
与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。
例如，一个没有通信功能的字处理程序就不能执行通信的代码，
从事字处理工作的程序员也不关心OSI的第7层。但是，如果添加了一个
传输文件的选项，那么字处理器的程序员就需要实现OSI的第7层。
示例：TELNET，HTTP，FTP，NFS，SMTP等。
表示层
这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制
或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。
如果选择ASCII格式，发送方将把文本从发送方的字符集转换成标准的ASCII后
发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。示例：加密，ASCII等。
会话层
它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，
以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，
在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。示例：RPC，SQL等。
传输层
这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同
应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。
示例：TCP，UDP，SPX。
网络层
这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了
路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，
网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。
数据链路层
它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。
物理层
OSI的物理层规范是有关传输介质的特性标准，这些规范通常也参考了其他组织制定的标准。
连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。
物理层常用多个规范完成对所有细节的定义。示例：Rj45，802.3等。
 */

/*
 * IP地址:系统把IP地址面向对象了------InetAddress
 */

/*
 * 使用Udp协议实现数据的发送与接收
 * 
 * 实现发送
 * 1.创建Socket端点(套接字)
 * 2.明确要发送的数据
 * 3.使用Socket的发送功能发送数据
 */

/*
 * 接收数据
 * 
 * 1.创建Socket端点
 * 2.创建空的数据包接收数据
 * 3.使用Socket接收数据

//获取发送数据的主机
//获取端口
 */

//连续发送     连续接收
第二十六天
//简单介绍TCP,实现双向通信
/*
 * TCP:会建立连接
 * Socket:客户端的套接字端点
 * 
 * 
 * 在客户端与服务器端进行数据传输时,对于客户端来说要进行输出和输入,
 * 而在Socket里面既有输出流又有输出流.在进行数据传输时,是将数据保存到Socket对象里面
 * 将socket对象传到服务器端,这时客户端和服务端在进行操作的时候相当于都有了同一个socket对象,
 * 我们便可以通过操作他实现数据的传输
 * 
 * ServerSocket:服务器端的套接字端点:只是负责绑定端口,接收从客户端传过来的socket对象.
 */

//1：创建Socket客户端对象
		//创建了一个客户端对象，同时指明连接的服务器IP地址和端口号
		//这行代码执行成功，说明客户端对象创建成功，同时和服务器连接成功
		//和服务器连接成功,相当于和服务器端建立了一条通道
		//这条通道就是Sockt流,也就是客户端对象，Sockt流中既有字节输入流，也有字节输出流

//写一个简单例子
/*
 * 实现一个大写转换服务器：客户端接收键盘输入的小写字符串发送给服务器端
	 *               服务器端把接收到的小写字符串转成大写再发给客户端
	 *               
	 *               分析:客户端:1创建Socket对象
	 *               2.准备数据
	 *               
	 *               服务器端:
	 *               1.建立服务器socket,绑定端口
	 *               2.获取socket对象,进行操作
 */

//实现图片的上传   FileInputStream

//实现文件的上传   FileWriter

//URL类
c盘-Windows-System32-drivers-etc-hosts  可以设置本机访问的域名地址

第二十七天
1.反射
/*
 * 反射:动态获取类(字节码文件),并对其成员进行运行
 * 
 * 字节码文件:Person.class  
 * 拥有了字节码文件,在创建对象时,就不需要调用new方法,调用属性的时候也不需要对象的应用
 * 
 * 获取class的方式
 * 1.使用object提供的Class<?> getClass() 方法得到字节码文件
 * 必须有一个对象
 * 2.每个数据类型都有一个class属性,通过该属性得到字节码文件对象
 * 需要这种类型事先存在
 * 3.使用Class的静态方法forName(""),字符串由  包名+类名 构成
 *  只需提供一个字符串
 */

//创建Person类
快速创建属性,方法,构造方法

//动态得到字节码文件并创建对象
//使用无参的构造方法创造对象
//使用带参数的


//动态创建类并给属性赋值


//静态创建类并执行方法
//非静态无参
//非静态有参
//静态有参

//举例说明
/*
 * 电脑运行起来
 * 电脑使用键盘
 * 电脑使用键盘
 * 
 */

创建主类

创建电脑类
鼠标类
键盘类

USB接口

创建文件


//正则表达式

/*
 * 专门用于字符串的操作
 * 
 * 例子:验证QQ号是否合法,5-15位,不能以0开头,全是数字
 */


/*
 * 使用
 * 1.匹配
 * 使用的是String类中的boolean matches(String regex)方法
 * 2.切割
 * 使用的是String类中的 String[] split(String regex)方法
 * 依据正则表达式的字符串来切割
 * 3.替换
 * 使用的是String类中的 String replaceAll(String regex, String replacement)  
 * 把字符串中符合正则表达式的内容替换成第二个参数的内容
 * 4.获取
 * 
 */






















